package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type weatherResponse struct { //Generated by https://transform.tools/json-to-go
	Data struct {
		Timelines []struct {
			Timestep  string    `json:"timestep"`
			EndTime   time.Time `json:"endTime"`
			StartTime time.Time `json:"startTime"`
			Intervals []struct {
				StartTime time.Time `json:"startTime"`
				Values    struct {
					Temperature         float64 `json:"temperature"`
					TemperatureApparent float64 `json:"temperatureApparent"`
					WeatherCode         int     `json:"weatherCode"`
				} `json:"values"`
			} `json:"intervals"`
		} `json:"timelines"`
	} `json:"data"`
}

type intervals []struct {
	StartTime time.Time `json:"startTime"`
	Values    struct {
		Temperature         float64 `json:"temperature"`
		TemperatureApparent float64 `json:"temperatureApparent"`
		WeatherCode         int     `json:"weatherCode"`
	} `json:"values"`
}

// FetchWeatherData fetches weather forecast data from the Tomorrow.io API for a specified location and time range.
// The weather data includes temperature, weather code, and apparent temperature.
//
// Note:
// - Make sure the environment variables TOMORROW_API_KEY, LOCATION, and TIMEZONE are set before calling this function.
// - The returned weatherInterval intervals will be in the specified timezone.
func getWeatherForecast() intervals {
	url := fmt.Sprintf("https://api.tomorrow.io/v4/timelines?apikey=%s", os.Getenv("TOMORROW_API_KEY"))

	payload := strings.NewReader(fmt.Sprintf("{\"location\":\"%s\",\"fields\":[\"temperature\",\"weatherCode\",\"temperatureApparent\"],"+
		"\"units\":\"metric\",\"timesteps\":[\"1h\"],\"startTime\":\"now\",\"endTime\":\"nowPlus18h\"}", os.Getenv("LOCATION")))

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, err := http.DefaultClient.Do(req)
	check(err)
	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)
	responseStr := string(body)

	var weatherData weatherResponse
	err = json.Unmarshal([]byte(responseStr), &weatherData)
	check(err)

	// log.Info(weatherData)

	interval := weatherData.Data.Timelines[0].Intervals

	for i := range interval {
		locTime, err := time.LoadLocation(os.Getenv("TIMEZONE"))
		check(err)
		interval[i].StartTime = interval[i].StartTime.In(locTime)
	}

	return interval

}
