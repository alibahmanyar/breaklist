package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type weatherResponse struct { //Generated by https://transform.tools/json-to-go
	Data struct {
		Timelines []struct {
			Timestep  string    `json:"timestep"`
			EndTime   time.Time `json:"endTime"`
			StartTime time.Time `json:"startTime"`
			Intervals []struct {
				StartTime time.Time `json:"startTime"`
				Values    struct {
					Temperature         float64 `json:"temperature"`
					TemperatureApparent float64 `json:"temperatureApparent"`
					WeatherCode         int     `json:"weatherCode"`
				} `json:"values"`
			} `json:"intervals"`
		} `json:"timelines"`
	} `json:"data"`
}

type weatherForecast struct {
	StartTime  time.Time `json:"startTime"`
	TimeString string    `json:"timeString"`
	Values     struct {
		Temperature         string `json:"temperature"`
		TemperatureApparent string `json:"temperatureApparent"`
		WeatherCode         int    `json:"weatherCode"`
	} `json:"values"`
}

// FetchWeatherData fetches weather forecast data from the Tomorrow.io API for a specified location and time range.
// The weather data includes temperature, weather code, and apparent temperature.
//
// Note:
// - Make sure the environment variables TOMORROW_API_KEY, LOCATION, and TIMEZONE are set before calling this function.
// - The returned weatherInterval intervals will be in the specified timezone.
func getWeatherForecast() []weatherForecast {
	url := fmt.Sprintf("https://api.tomorrow.io/v4/timelines?apikey=%s", os.Getenv("TOMORROW_API_KEY"))

	payload := strings.NewReader(fmt.Sprintf("{\"location\":\"%s\",\"fields\":[\"temperature\",\"weatherCode\",\"temperatureApparent\"],"+
		"\"units\":\"metric\",\"timesteps\":[\"1h\"],\"startTime\":\"now\",\"endTime\":\"nowPlus18h\"}", os.Getenv("LOCATION")))

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, err := http.DefaultClient.Do(req)
	check(err)
	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)
	responseStr := string(body)
	// log.Info(responseStr)

	var weatherData weatherResponse
	err = json.Unmarshal([]byte(responseStr), &weatherData)
	check(err)

	intvl := weatherData.Data.Timelines[0].Intervals

	var forecast []weatherForecast

	locTime, err := time.LoadLocation(os.Getenv("TIMEZONE"))
	check(err)

	for i := range intvl {
		intvl[i].StartTime = intvl[i].StartTime.In(locTime)

		forecast = append(forecast, weatherForecast{
			StartTime:  intvl[i].StartTime,
			TimeString: intvl[i].StartTime.Format("15:04"),
			Values: struct {
				Temperature         string `json:"temperature"`
				TemperatureApparent string `json:"temperatureApparent"`
				WeatherCode         int    `json:"weatherCode"`
			}{
				Temperature:         fmt.Sprintf("%.2f", intvl[i].Values.Temperature),
				TemperatureApparent: fmt.Sprintf("%.2f", intvl[i].Values.TemperatureApparent),
				WeatherCode:         intvl[i].Values.WeatherCode,
			},
		})
	}

	return forecast

}
